<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>Basic Principles &#8212; Yosys  documentation</title>

    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/material-icons.css" type="text/css" />
    <link rel="stylesheet" href="_static/notosanscjkjp.css" type="text/css" />
    <link rel="stylesheet" href="_static/roboto.css" type="text/css" />
    <link rel="stylesheet" href="_static/material-design-lite-1.3.0/material.deep_purple-purple.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx_symbiflow_theme.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/sphinx_symbiflow_theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Approach" href="CHAPTER_Approach.html" />
    <link rel="prev" title="Introduction" href="CHAPTER_Intro.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link is-active">Basic Principles</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
            <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="_sources/CHAPTER_Basics.rst.txt" rel="nofollow">
<i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          <a  class="mdl-navigation__link" href="index.html">
                  <i class="material-icons navigation-link-icon">home</i>
                  Home
              </a>
          
              <a  class="mdl-navigation__link" href="https://github.com/YosysHQ/yosys">
                  <i class="material-icons navigation-link-icon">link</i>
                  GitHub
              </a>
      
          <a  class="mdl-navigation__link" href="https://symbiflow.github.io/">
            <i class="material-icons navigation-link-icon">web</i>
            SymbiFlow Website
          </a>
          <a  class="mdl-navigation__link" href="https://symbiflow.readthedocs.io/en/latest/">
            <i class="material-icons navigation-link-icon">library_books</i>
            SymbiFlow Docs
          </a></nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="index.html">
              <span class="title-text">
                  Yosys
              </span>
          </a>
      </span>
    
<div class="globaltoc">
  <span class="mdl-layout-title toc">Table Of Contents</span>
  
  
      
      <nav class="mdl-navigation">
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Approach.html">Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Overview.html">Implementation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_CellLib.html">Internal Cell Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Prog.html">Programming Yosys Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Verilog.html">The Verilog and AST Frontends</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Optimize.html">Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Techmap.html">Technology Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Eval.html">Evaluation, Conclusion, Future Work</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Auxlibs.html">Auxiliary Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Auxprogs.html">Auxiliary Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_TextRtlil.html">RTLIL Text Representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Appnotes.html">Application Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_StateOfTheArt.html">Evaluation of other OSS Verilog Synthesis Tools</a></li>
</ul>

      </nav>
  
  </div>

</header>
        <main class="mdl-layout__content" tabIndex="0">
<header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="index.html">
              <span class="title-text">
                  Yosys
              </span>
          </a>
      </span>
    
<div class="globaltoc">
  <span class="mdl-layout-title toc">Table Of Contents</span>
  
  
      
      <nav class="mdl-navigation">
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Approach.html">Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Overview.html">Implementation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_CellLib.html">Internal Cell Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Prog.html">Programming Yosys Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Verilog.html">The Verilog and AST Frontends</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Optimize.html">Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Techmap.html">Technology Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Eval.html">Evaluation, Conclusion, Future Work</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Auxlibs.html">Auxiliary Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Auxprogs.html">Auxiliary Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_TextRtlil.html">RTLIL Text Representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_Appnotes.html">Application Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHAPTER_StateOfTheArt.html">Evaluation of other OSS Verilog Synthesis Tools</a></li>
</ul>

      </nav>
  
  </div>

</header>

    <div class="document">
        <div class="page-content">
        
  <div class="section" id="basic-principles">
<span id="chapter-basics"></span><h1>Basic Principles<a class="headerlink" href="#basic-principles" title="Permalink to this headline">¶</a></h1>
<p>This chapter contains a short introduction to the basic principles of
digital circuit synthesis.</p>
<div class="section" id="levels-of-abstraction">
<h2>Levels of Abstraction<a class="headerlink" href="#levels-of-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Digital circuits can be represented at different levels of abstraction.
During the design process a circuit is usually first specified using a
higher level abstraction. Implementation can then be understood as
finding a functionally equivalent representation at a lower abstraction
level. When this is done automatically using software, the term
<em>synthesis</em> is used.</p>
<p>So synthesis is the automatic conversion of a high-level representation
of a circuit to a functionally equivalent low-level representation of a
circuit. Figure <a class="reference external" href="#fig:Basics_abstractions">[fig:Basics_abstractions]</a>
lists the different levels of abstraction and how they relate to
different kinds of synthesis.</p>
<p>Regardless of the way a lower level representation of a circuit is
obtained (synthesis or manual design), the lower level representation is
usually verified by comparing simulation results of the lower level and
the higher level representation  <a class="footnote-reference brackets" href="#id2" id="id1">1</a>. Therefore even if no synthesis is
used, there must still be a simulatable representation of the circuit in
all levels to allow for verification of the design.</p>
<p>Note: The exact meaning of terminology such as “High-Level” is of course
not fixed over time. For example the HDL “ABEL” was first introduced in
1985 as “A High-Level Design Language for Programmable Logic Devices”
, but would not be considered a “High-Level
Language” today.</p>
<div class="section" id="system-level">
<h3>System Level<a class="headerlink" href="#system-level" title="Permalink to this headline">¶</a></h3>
<p>The System Level abstraction of a system only looks at its biggest
building blocks like CPUs and computing cores. At this level the circuit
is usually described using traditional programming languages like C/C++
or Matlab. Sometimes special software libraries are used that are aimed
at simulation circuits on the system level, such as SystemC.</p>
<p>Usually no synthesis tools are used to automatically transform a system
level representation of a circuit to a lower-level representation. But
system level design tools exist that can be used to connect system level
building blocks.</p>
<p>The IEEE 1685-2009 standard defines the IP-XACT file format that can be
used to represent designs on the system level and building blocks that
can be used in such system level designs. </p>
</div>
<div class="section" id="high-level">
<h3>High Level<a class="headerlink" href="#high-level" title="Permalink to this headline">¶</a></h3>
<p>The high-level abstraction of a system (sometimes referred to as
<em>algorithmic</em> level) is also often represented using traditional
programming languages, but with a reduced feature set. For example when
representing a design at the high level abstraction in C, pointers can
only be used to mimic concepts that can be found in hardware, such as
memory interfaces. Full featured dynamic memory management is not
allowed as it has no corresponding concept in digital circuits.</p>
<p>Tools exist to synthesize high level code (usually in the form of
C/C++/SystemC code with additional metadata) to behavioural HDL code
(usually in the form of Verilog or VHDL code). Aside from the many
commercial tools for high level synthesis there are also a number of
FOSS tools for high level synthesis .</p>
</div>
<div class="section" id="behavioural-level">
<h3>Behavioural Level<a class="headerlink" href="#behavioural-level" title="Permalink to this headline">¶</a></h3>
<p>At the behavioural abstraction level a language aimed at hardware
description such as Verilog or VHDL is used to describe the circuit, but
so-called <em>behavioural modelling</em> is used in at least part of the
circuit description. In behavioural modelling there must be a language
feature that allows for imperative programming to be used to describe
data paths and registers. This is the <code class="docutils literal notranslate"><span class="pre">always</span></code>-block in Verilog and
the <code class="docutils literal notranslate"><span class="pre">process</span></code>-block in VHDL.</p>
<p>In behavioural modelling, code fragments are provided together with a
<em>sensitivity list</em>; a list of signals and conditions. In simulation, the
code fragment is executed whenever a signal in the sensitivity list
changes its value or a condition in the sensitivity list is triggered. A
synthesis tool must be able to transfer this representation into an
appropriate datapath followed by the appropriate types of register.</p>
<p>For example consider the following Verilog code fragment:</p>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>In simulation the statement <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> is executed whenever a
positive edge on the signal <code class="docutils literal notranslate"><span class="pre">clk</span></code> is detected. The synthesis result
however will contain an adder that calculates the sum <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> all the
time, followed by a d-type flip-flop with the adder output on its
D-input and the signal <code class="docutils literal notranslate"><span class="pre">y</span></code> on its Q-output.</p>
<p>Usually the imperative code fragments used in behavioural modelling can
contain statements for conditional execution (<code class="docutils literal notranslate"><span class="pre">if</span></code>- and
<code class="docutils literal notranslate"><span class="pre">case</span></code>-statements in Verilog) as well as loops, as long as those loops
can be completely unrolled.</p>
<p>Interestingly there seems to be no other FOSS Tool that is capable of
performing Verilog or VHDL behavioural syntheses besides Yosys (see
App. <a class="reference external" href="#chapter:sota">[chapter:sota]</a>).</p>
</div>
<div class="section" id="register-transfer-level-rtl">
<h3>Register-Transfer Level (RTL)<a class="headerlink" href="#register-transfer-level-rtl" title="Permalink to this headline">¶</a></h3>
<p>On the Register-Transfer Level the design is represented by
combinatorial data paths and registers (usually d-type flip flops). The
following Verilog code fragment is equivalent to the previous Verilog
example, but is in RTL representation:</p>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">assign</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">// combinatorial data path</span>

<span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span>     <span class="c1">// register</span>
    <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>A design in RTL representation is usually stored using HDLs like Verilog
and VHDL. But only a very limited subset of features is used, namely
minimalistic <code class="docutils literal notranslate"><span class="pre">always</span></code>-blocks (Verilog) or <code class="docutils literal notranslate"><span class="pre">process</span></code>-blocks (VHDL)
that model the register type used and unconditional assignments for the
datapath logic. The use of HDLs on this level simplifies simulation as
no additional tools are required to simulate a design in RTL
representation.</p>
<p>Many optimizations and analyses can be performed best at the RTL level.
Examples include FSM detection and optimization, identification of
memories or other larger building blocks and identification of shareable
resources.</p>
<p>Note that RTL is the first abstraction level in which the circuit is
represented as a graph of circuit elements (registers and combinatorial
cells) and signals. Such a graph, when encoded as list of cells and
connections, is called a netlist.</p>
<p>RTL synthesis is easy as each circuit node element in the netlist can
simply be replaced with an equivalent gate-level circuit. However,
usually the term <em>RTL synthesis</em> does not only refer to synthesizing an
RTL netlist to a gate level netlist but also to performing a number of
highly sophisticated optimizations within the RTL representation, such
as the examples listed above.</p>
<p>A number of FOSS tools exist that can perform isolated tasks within the
domain of RTL synthesis steps. But there seems to be no FOSS tool that
covers a wide range of RTL synthesis operations.</p>
</div>
<div class="section" id="logical-gate-level">
<h3>Logical Gate Level<a class="headerlink" href="#logical-gate-level" title="Permalink to this headline">¶</a></h3>
<p>At the logical gate level the design is represented by a netlist that
uses only cells from a small number of single-bit cells, such as basic
logic gates (AND, OR, NOT, XOR, etc.) and registers (usually D-Type
Flip-flops).</p>
<p>A number of netlist formats exists that can be used on this level,
e.g. the Electronic Design Interchange Format (EDIF), but for ease of
simulation often a HDL netlist is used. The latter is a HDL file
(Verilog or VHDL) that only uses the most basic language constructs for
instantiation and connecting of cells.</p>
<p>There are two challenges in logic synthesis: First finding opportunities
for optimizations within the gate level netlist and second the optimal
(or at least good) mapping of the logic gate netlist to an equivalent
netlist of physically available gate types.</p>
<p>The simplest approach to logic synthesis is <em>two-level logic synthesis</em>,
where a logic function is converted into a sum-of-products
representation, e.g. using a Karnaugh map. This is a simple approach,
but has exponential worst-case effort and cannot make efficient use of
physical gates other than AND/NAND-, OR/NOR- and NOT-Gates.</p>
<p>Therefore modern logic synthesis tools utilize much more complicated
<em>multi-level logic synthesis</em> algorithms
. Most of these algorithms
convert the logic function to a Binary-Decision-Diagram (BDD) or
And-Inverter-Graph (AIG) and work from that representation. The former
has the advantage that it has a unique normalized form. The latter has
much better worst case performance and is therefore better suited for
the synthesis of large logic functions.</p>
<p>Good FOSS tools exists for multi-level logic synthesis .</p>
<p>Yosys contains basic logic synthesis functionality but can also use ABC
for the logic synthesis step. Using ABC is recommended.</p>
</div>
<div class="section" id="physical-gate-level">
<h3>Physical Gate Level<a class="headerlink" href="#physical-gate-level" title="Permalink to this headline">¶</a></h3>
<p>On the physical gate level only gates are used that are physically
available on the target architecture. In some cases this may only be
NAND, NOR and NOT gates as well as D-Type registers. In other cases this
might include cells that are more complex than the cells used at the
logical gate level (e.g. complete half-adders). In the case of an
FPGA-based design the physical gate level representation is a netlist of
LUTs with optional output registers, as these are the basic building
blocks of FPGA logic cells.</p>
<p>For the synthesis tool chain this abstraction is usually the lowest
level. In case of an ASIC-based design the cell library might contain
further information on how the physical cells map to individual switches
(transistors).</p>
</div>
<div class="section" id="switch-level">
<h3>Switch Level<a class="headerlink" href="#switch-level" title="Permalink to this headline">¶</a></h3>
<p>A switch level representation of a circuit is a netlist utilizing single
transistors as cells. Switch level modelling is possible in Verilog and
VHDL, but is seldom used in modern designs, as in modern digital ASIC or
FPGA flows the physical gates are considered the atomic build blocks of
the logic circuit.</p>
</div>
<div class="section" id="yosys">
<h3>Yosys<a class="headerlink" href="#yosys" title="Permalink to this headline">¶</a></h3>
<p>Yosys is a Verilog HDL synthesis tool. This means that it takes a
behavioural design description as input and generates an RTL, logical
gate or physical gate level description of the design as output. Yosys’
main strengths are behavioural and RTL synthesis. A wide range of
commands (synthesis passes) exist within Yosys that can be used to
perform a wide range of synthesis tasks within the domain of
behavioural, rtl and logic synthesis. Yosys is designed to be extensible
and therefore is a good basis for implementing custom synthesis tools
for specialised tasks.</p>
</div>
</div>
<div class="section" id="features-of-synthesizable-verilog">
<h2>Features of Synthesizable Verilog<a class="headerlink" href="#features-of-synthesizable-verilog" title="Permalink to this headline">¶</a></h2>
<p>The subset of Verilog  that is
synthesizable is specified in a separate IEEE standards document, the
IEEE standard 1364.1-2002 . This
standard also describes how certain language constructs are to be
interpreted in the scope of synthesis.</p>
<p>This section provides a quick overview of the most important features of
synthesizable Verilog, structured in order of increasing complexity.</p>
<div class="section" id="structural-verilog">
<h3>Structural Verilog<a class="headerlink" href="#structural-verilog" title="Permalink to this headline">¶</a></h3>
<p><em>Structural Verilog</em> (also known as <em>Verilog Netlists</em>) is a Netlist in
Verilog syntax. Only the following language constructs are used in this
case:</p>
<ul class="simple">
<li><p>Constant values</p></li>
<li><p>Wire and port declarations</p></li>
<li><p>Static assignments of signals to other signals</p></li>
<li><p>Cell instantiations</p></li>
</ul>
<p>Many tools (especially at the back end of the synthesis chain) only
support structural Verilog as input. ABC is an example of such a tool.
Unfortunately there is no standard specifying what <em>Structural Verilog</em>
actually is, leading to some confusion about what syntax constructs are
supported in structural Verilog when it comes to features such as
attributes or multi-bit signals.</p>
</div>
<div class="section" id="expressions-in-verilog">
<h3>Expressions in Verilog<a class="headerlink" href="#expressions-in-verilog" title="Permalink to this headline">¶</a></h3>
<p>In all situations where Verilog accepts a constant value or signal name,
expressions using arithmetic operations such as <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code>,
boolean operations such as <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> (AND), <code class="docutils literal notranslate"><span class="pre">|</span></code> (OR) and <code class="docutils literal notranslate"><span class="pre">^</span></code> (XOR) and
many others (comparison operations, unary operator, etc.) can also be
used.</p>
<p>During synthesis these operators are replaced by cells that implement
the respective function.</p>
<p>Many FOSS tools that claim to be able to process Verilog in fact only
support basic structural Verilog and simple expressions. Yosys can be
used to convert full featured synthesizable Verilog to this simpler
subset, thus enabling such applications to be used with a richer set of
Verilog features.</p>
</div>
<div class="section" id="behavioural-modelling">
<h3>Behavioural Modelling<a class="headerlink" href="#behavioural-modelling" title="Permalink to this headline">¶</a></h3>
<p>Code that utilizes the Verilog <code class="docutils literal notranslate"><span class="pre">always</span></code> statement is using
<em>Behavioural Modelling</em>. In behavioural modelling, a circuit is
described by means of imperative program code that is executed on
certain events, namely any change, a rising edge, or a falling edge of a
signal. This is a very flexible construct during simulation but is only
synthesizable when one of the following is modelled:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>Asynchronous or latched logic</strong></div>
<div class="line">In this case the sensitivity list must contain all expressions that
are used within the <code class="docutils literal notranslate"><span class="pre">always</span></code> block. The syntax <code class="docutils literal notranslate"><span class="pre">&#64;*</span></code> can be used
for these cases. Examples of this kind include:</div>
</div>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// asynchronous</span>
<span class="k">always</span> <span class="p">@</span><span class="o">*</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">add_mode</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="k">end</span>

<span class="c1">// latched</span>
<span class="k">always</span> <span class="p">@</span><span class="o">*</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hold</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
<p>Note that latched logic is often considered bad style and in many
cases just the result of sloppy HDL design. Therefore many synthesis
tools generate warnings whenever latched logic is generated.</p>
</li>
<li><div class="line-block">
<div class="line"><strong>Synchronous logic (with optional synchronous reset)</strong></div>
<div class="line">This is logic with d-type flip-flops on the output. In this case
the sensitivity list must only contain the respective clock edge.
Example:</div>
</div>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// counter with synchronous reset</span>
<span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="mh">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
</li>
<li><div class="line-block">
<div class="line"><strong>Synchronous logic with asynchronous reset</strong></div>
<div class="line">This is logic with d-type flip-flops with asynchronous resets on
the output. In this case the sensitivity list must only contain the
respective clock and reset edges. The values assigned in the reset
branch must be constant. Example:</div>
</div>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// counter with asynchronous reset</span>
<span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">,</span> <span class="k">posedge</span> <span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="mh">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
</li>
</ul>
<p>Many synthesis tools support a wider subset of flip-flops that can be
modelled using <code class="docutils literal notranslate"><span class="pre">always</span></code>-statements (including Yosys). But only the
ones listed above are covered by the Verilog synthesis standard and when
writing new designs one should limit herself or himself to these cases.</p>
<p>In behavioural modelling, blocking assignments (=) and non-blocking
assignments (&lt;=) can be used. The concept of blocking vs. non-blocking
assignment is one of the most misunderstood constructs in Verilog
.</p>
<p>The blocking assignment behaves exactly like an assignment in any
imperative programming language, while with the non-blocking assignment
the right hand side of the assignment is evaluated immediately but the
actual update of the left hand side register is delayed until the end of
the time-step. For example the Verilog code <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b;</span> <span class="pre">b</span> <span class="pre">&lt;=</span> <span class="pre">a;</span></code>
exchanges the values of the two registers. See
Sec. <a class="reference external" href="#sec:blocking_nonblocking">[sec:blocking_nonblocking]</a> for a
more detailed description of this behaviour.</p>
</div>
<div class="section" id="functions-and-tasks">
<h3>Functions and Tasks<a class="headerlink" href="#functions-and-tasks" title="Permalink to this headline">¶</a></h3>
<p>Verilog supports <em>Functions</em> and <em>Tasks</em> to bundle statements that are
used in multiple places (similar to <em>Procedures</em> in imperative
programming). Both constructs can be implemented easily by substituting
the function/task-call with the body of the function or task.</p>
</div>
<div class="section" id="conditionals-loops-and-generate-statements">
<h3>Conditionals, Loops and Generate-Statements<a class="headerlink" href="#conditionals-loops-and-generate-statements" title="Permalink to this headline">¶</a></h3>
<p>Verilog supports <code class="docutils literal notranslate"><span class="pre">if-else</span></code>-statements and <code class="docutils literal notranslate"><span class="pre">for</span></code>-loops inside
<code class="docutils literal notranslate"><span class="pre">always</span></code>-statements.</p>
<p>It also supports both features in <code class="docutils literal notranslate"><span class="pre">generate</span></code>-statements on the module
level. This can be used to selectively enable or disable parts of the
module based on the module parameters (<code class="docutils literal notranslate"><span class="pre">if-else</span></code>) or to generate a set
of similar subcircuits (<code class="docutils literal notranslate"><span class="pre">for</span></code>).</p>
<p>While the <code class="docutils literal notranslate"><span class="pre">if-else</span></code>-statement inside an always-block is part of
behavioural modelling, the three other cases are (at least for a
synthesis tool) part of a built-in macro processor. Therefore it must be
possible for the synthesis tool to completely unroll all loops and
evaluate the condition in all <code class="docutils literal notranslate"><span class="pre">if-else</span></code>-statement in
<code class="docutils literal notranslate"><span class="pre">generate</span></code>-statements using const-folding.</p>
<p>Examples for this can be found in
Fig. <a class="reference external" href="#fig:StateOfTheArt_for">[fig:StateOfTheArt_for]</a> and
Fig. <a class="reference external" href="#fig:StateOfTheArt_gen">[fig:StateOfTheArt_gen]</a> in
App. <a class="reference external" href="#chapter:sota">[chapter:sota]</a>.</p>
</div>
<div class="section" id="arrays-and-memories">
<h3>Arrays and Memories<a class="headerlink" href="#arrays-and-memories" title="Permalink to this headline">¶</a></h3>
<p>Verilog supports arrays. This is in general a synthesizable language
feature. In most cases arrays can be synthesized by generating
addressable memories. However, when complex or asynchronous access
patterns are used, it is not possible to model an array as memory. In
these cases the array must be modelled using individual signals for each
word and all accesses to the array must be implemented using large
multiplexers.</p>
<p>In some cases it would be possible to model an array using memories, but
it is not desired. Consider the following delay circuit:</p>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">out_data</span><span class="p">);</span>

<span class="k">parameter</span> <span class="n">BITS</span> <span class="o">=</span> <span class="mh">8</span><span class="p">;</span>
<span class="k">parameter</span> <span class="n">STAGES</span> <span class="o">=</span> <span class="mh">4</span><span class="p">;</span>

<span class="k">input</span> <span class="n">clk</span><span class="p">;</span>
<span class="k">input</span> <span class="p">[</span><span class="n">BITS</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">in_data</span><span class="p">;</span>
<span class="k">output</span> <span class="p">[</span><span class="n">BITS</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out_data</span><span class="p">;</span>
<span class="kt">reg</span> <span class="p">[</span><span class="n">BITS</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ffs</span> <span class="p">[</span><span class="n">STAGES</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span>

<span class="k">integer</span> <span class="n">i</span><span class="p">;</span>
<span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">ffs</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">in_data</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STAGES</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span>
        <span class="n">ffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ffs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mh">1</span><span class="p">];</span>
<span class="k">end</span>

<span class="k">assign</span> <span class="n">out_data</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">[</span><span class="n">STAGES</span><span class="o">-</span><span class="mh">1</span><span class="p">];</span>

<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<p>This could be implemented using an addressable memory with <code class="docutils literal notranslate"><span class="pre">STAGES</span></code>
input and output ports. A better implementation would be to use a simple
chain of flip-flops (a so-called shift register). This better
implementation can either be obtained by first creating a memory-based
implementation and then optimizing it based on the static address
signals for all ports or directly identifying such situations in the
language front end and converting all memory accesses to direct accesses
to the correct signals.</p>
</div>
</div>
<div class="section" id="challenges-in-digital-circuit-synthesis">
<h2>Challenges in Digital Circuit Synthesis<a class="headerlink" href="#challenges-in-digital-circuit-synthesis" title="Permalink to this headline">¶</a></h2>
<p>This section summarizes the most important challenges in digital circuit
synthesis. Tools can be characterized by how well they address these
topics.</p>
<div class="section" id="standards-compliance">
<h3>Standards Compliance<a class="headerlink" href="#standards-compliance" title="Permalink to this headline">¶</a></h3>
<p>The most important challenge is compliance with the HDL standards in
question (in case of Verilog the IEEE Standards 1364.1-2002 and
1364-2005). This can be broken down in two items:</p>
<ul class="simple">
<li><p>Completeness of implementation of the standard</p></li>
<li><p>Correctness of implementation of the standard</p></li>
</ul>
<p>Completeness is mostly important to guarantee compatibility with
existing HDL code. Once a design has been verified and tested, HDL
designers are very reluctant regarding changes to the design, even if it
is only about a few minor changes to work around a missing feature in a
new synthesis tool.</p>
<p>Correctness is crucial. In some areas this is obvious (such as correct
synthesis of basic behavioural models). But it is also crucial for the
areas that concern minor details of the standard, such as the exact
rules for handling signed expressions, even when the HDL code does not
target different synthesis tools. This is because (unlike software
source code that is only processed by compilers), in most design flows
HDL code is not only processed by the synthesis tool but also by one or
more simulators and sometimes even a formal verification tool. It is key
for this verification process that all these tools use the same
interpretation for the HDL code.</p>
</div>
<div class="section" id="optimizations">
<h3>Optimizations<a class="headerlink" href="#optimizations" title="Permalink to this headline">¶</a></h3>
<p>Generally it is hard to give a one-dimensional description of how well a
synthesis tool optimizes the design. First of all because not all
optimizations are applicable to all designs and all synthesis tasks.
Some optimizations work (best) on a coarse-grained level (with complex
cells such as adders or multipliers) and others work (best) on a
fine-grained level (single bit gates). Some optimizations target area
and others target speed. Some work well on large designs while others
don’t scale well and can only be applied to small designs.</p>
<p>A good tool is capable of applying a wide range of optimizations at
different levels of abstraction and gives the designer control over
which optimizations are performed (or skipped) and what the optimization
goals are.</p>
</div>
<div class="section" id="technology-mapping">
<h3>Technology Mapping<a class="headerlink" href="#technology-mapping" title="Permalink to this headline">¶</a></h3>
<p>Technology mapping is the process of converting the design into a
netlist of cells that are available in the target architecture. In an
ASIC flow this might be the process-specific cell library provided by
the fab. In an FPGA flow this might be LUT cells as well as special
function units such as dedicated multipliers. In a coarse-grain flow
this might even be more complex special function units.</p>
<p>An open and vendor independent tool is especially of interest if it
supports a wide range of different types of target architectures.</p>
</div>
</div>
<div class="section" id="script-based-synthesis-flows">
<h2>Script-Based Synthesis Flows<a class="headerlink" href="#script-based-synthesis-flows" title="Permalink to this headline">¶</a></h2>
<p>A digital design is usually started by implementing a high-level or
system-level simulation of the desired function. This description is
then manually transformed (or re-implemented) into a synthesizable
lower-level description (usually at the behavioural level) and the
equivalence of the two representations is verified by simulating both
and comparing the simulation results.</p>
<p>Then the synthesizable description is transformed to lower-level
representations using a series of tools and the results are again
verified using simulation. This process is illustrated in
Fig. <a class="reference external" href="#fig:Basics_flow">[fig:Basics_flow]</a>.</p>
<p>In this example the System Level Model and the Behavioural Model are
both manually written design files. After the equivalence of system
level model and behavioural model has been verified, the lower level
representations of the design can be generated using synthesis tools.
Finally the RTL Model and the Gate-Level Model are verified and the
design process is finished.</p>
<p>However, in any real-world design effort there will be multiple
iterations for this design process. The reason for this can be the late
change of a design requirement or the fact that the analysis of a
low-abstraction model (e.g. gate-level timing analysis) revealed that a
design change is required in order to meet the design requirements
(e.g. maximum possible clock speed).</p>
<p>Whenever the behavioural model or the system level model is changed
their equivalence must be re-verified by re-running the simulations and
comparing the results. Whenever the behavioural model is changed the
synthesis must be re-run and the synthesis results must be re-verified.</p>
<p>In order to guarantee reproducibility it is important to be able to
re-run all automatic steps in a design project with a fixed set of
settings easily. Because of this, usually all programs used in a
synthesis flow can be controlled using scripts. This means that all
functions are available via text commands. When such a tool provides a
GUI, this is complementary to, and not instead of, a command line
interface.</p>
<p>Usually a synthesis flow in an UNIX/Linux environment would be
controlled by a shell script that calls all required tools (synthesis
and simulation/verification in this example) in the correct order. Each
of these tools would be called with a script file containing commands
for the respective tool. All settings required for the tool would be
provided by these script files so that no manual interaction would be
necessary. These script files are considered design sources and should
be kept under version control just like the source code of the system
level and the behavioural model.</p>
</div>
<div class="section" id="methods-from-compiler-design">
<h2>Methods from Compiler Design<a class="headerlink" href="#methods-from-compiler-design" title="Permalink to this headline">¶</a></h2>
<p>Some parts of synthesis tools involve problem domains that are
traditionally known from compiler design. This section addresses some of
these domains.</p>
<div class="section" id="lexing-and-parsing">
<h3>Lexing and Parsing<a class="headerlink" href="#lexing-and-parsing" title="Permalink to this headline">¶</a></h3>
<p>The best known concepts from compiler design are probably <em>lexing</em> and
<em>parsing</em>. These are two methods that together can be used to process
complex computer languages easily. </p>
<p>A <em>lexer</em> consumes single characters from the input and generates a
stream of <em>lexical tokens</em> that consist of a <em>type</em> and a <em>value</em>. For
example the Verilog input “<code class="docutils literal notranslate"><span class="pre">assign</span> <span class="pre">foo</span> <span class="pre">=</span> <span class="pre">bar</span> <span class="pre">+</span> <span class="pre">42;</span></code>” might be
translated by the lexer to the list of lexical tokens given in
Tab. <a class="reference external" href="#tab:Basics_tokens">1.1</a>.</p>
<div class="docutils container" id="tab-basics-tokens">
<p>“<code class="docutils literal notranslate"><span class="pre">assign</span> <span class="pre">foo</span> <span class="pre">=</span> <span class="pre">bar</span> <span class="pre">+</span> <span class="pre">42;</span></code>”.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Token-Type</p></th>
<th class="head"><p>Token-Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_ASSIGN</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_IDENTIFIER</span></code></p></td>
<td><p>“<code class="docutils literal notranslate"><span class="pre">foo</span></code>”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_EQ</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_IDENTIFIER</span></code></p></td>
<td><p>“<code class="docutils literal notranslate"><span class="pre">bar</span></code>”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_PLUS</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_NUMBER</span></code></p></td>
<td><p>42</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TOK_SEMICOLON</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<p>The lexer is usually generated by a lexer generator (e.g. <code class="docutils literal notranslate"><span class="pre">flex</span></code> )
from a description file that is using regular expressions to specify the
text pattern that should match the individual tokens.</p>
<p>The lexer is also responsible for skipping ignored characters (such as
whitespace outside string constants and comments in the case of Verilog)
and converting the original text snippet to a token value.</p>
<p>Note that individual keywords use different token types (instead of a
keyword type with different token values). This is because the parser
usually can only use the Token-Type to make a decision on the
grammatical role of a token.</p>
<p>The parser then transforms the list of tokens into a parse tree that
closely resembles the productions from the computer languages grammar.
As the lexer, the parser is also typically generated by a code generator
(e.g. <code class="docutils literal notranslate"><span class="pre">bison</span></code> ) from a grammar description in Backus-Naur Form (BNF).</p>
<p>Let’s consider the following BNF (in Bison syntax):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">assign_stmt</span><span class="p">:</span> <span class="n">TOK_ASSIGN</span> <span class="n">TOK_IDENTIFIER</span> <span class="n">TOK_EQ</span> <span class="n">expr</span> <span class="n">TOK_SEMICOLON</span><span class="p">;</span>
<span class="n">expr</span><span class="p">:</span> <span class="n">TOK_IDENTIFIER</span> <span class="o">|</span> <span class="n">TOK_NUMBER</span> <span class="o">|</span> <span class="n">expr</span> <span class="n">TOK_PLUS</span> <span class="n">expr</span><span class="p">;</span>
</pre></div>
</div>
<p>The parser converts the token list to the parse tree in
Fig. <a class="reference external" href="#fig:Basics_parsetree">[fig:Basics_parsetree]</a>. Note that the
parse tree never actually exists as a whole as data structure in memory.
Instead the parser calls user-specified code snippets (so-called
<em>reduce-functions</em>) for all inner nodes of the parse tree in depth-first
order.</p>
<p>In some very simple applications (e.g. code generation for stack
machines) it is possible to perform the task at hand directly in the
reduce functions. But usually the reduce functions are only used to
build an in-memory data structure with the relevant information from the
parse tree. This data structure is called an <em>abstract syntax tree</em>
(AST).</p>
<p>The exact format for the abstract syntax tree is application specific
(while the format of the parse tree and token list are mostly dictated
by the grammar of the language at hand).
Figure <a class="reference external" href="#fig:Basics_ast">[fig:Basics_ast]</a> illustrates what an AST
for the parse tree in
Fig. <a class="reference external" href="#fig:Basics_parsetree">[fig:Basics_parsetree]</a> could look like.</p>
<p>Usually the AST is then converted into yet another representation that
is more suitable for further processing. In compilers this is often an
assembler-like three-address-code intermediate representation.
</p>
</div>
<div class="section" id="multi-pass-compilation">
<h3>Multi-Pass Compilation<a class="headerlink" href="#multi-pass-compilation" title="Permalink to this headline">¶</a></h3>
<p>Complex problems are often best solved when split up into smaller
problems. This is certainly true for compilers as well as for synthesis
tools. The components responsible for solving the smaller problems can
be connected in two different ways: through <em>Single-Pass Pipelining</em> and
by using <em>Multiple Passes</em>.</p>
<p>Traditionally a parser and lexer are connected using the pipelined
approach: The lexer provides a function that is called by the parser.
This function reads data from the input until a complete lexical token
has been read. Then this token is returned to the parser. So the lexer
does not first generate a complete list of lexical tokens and then pass
it to the parser. Instead they run concurrently and the parser can
consume tokens as the lexer produces them.</p>
<p>The single-pass pipelining approach has the advantage of lower memory
footprint (at no time must the complete design be kept in memory) but
has the disadvantage of tighter coupling between the interacting
components.</p>
<p>Therefore single-pass pipelining should only be used when the lower
memory footprint is required or the components are also conceptually
tightly coupled. The latter certainly is the case for a parser and its
lexer. But when data is passed between two conceptually loosely coupled
components it is often beneficial to use a multi-pass approach.</p>
<p>In the multi-pass approach the first component processes all the data
and the result is stored in a in-memory data structure. Then the second
component is called with this data. This reduces complexity, as only one
component is running at a time. It also improves flexibility as
components can be exchanged easier.</p>
<p>Most modern compilers are multi-pass compilers.</p>
</div>
<div class="section" id="static-single-assignment-form">
<h3>Static Single Assignment Form<a class="headerlink" href="#static-single-assignment-form" title="Permalink to this headline">¶</a></h3>
<p>In imperative programming (and behavioural HDL design) it is possible to
assign the same variable multiple times. This can either mean that the
variable is independently used in two different contexts or that the
final value of the variable depends on a condition.</p>
<p>The following examples show C code in which one variable is used
independently in two different contexts:</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">demo1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">demo1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">demo2</span><span class="p">(</span><span class="kt">bool</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">demo2</span><span class="p">(</span><span class="kt">bool</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In both examples the left version (only variable <code class="docutils literal notranslate"><span class="pre">a</span></code>) and the right
version (variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>) are equivalent. Therefore it is
desired for further processing to bring the code in an equivalent form
for both cases.</p>
<p>In the following example the variable is assigned twice but it cannot be
easily replaced by two variables:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">demo3</span><span class="p">(</span><span class="kt">bool</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">23</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Static single assignment (SSA) form is a representation of imperative
code that uses identical representations for the left and right version
of demos 1 and 2, but can still represent demo 3. In SSA form each
assignment assigns a new variable (usually written with an index). But
it also introduces a special <span class="math">\Phi</span>-function to merge the
different instances of a variable when needed. In C-pseudo-code the demo
3 would be written as follows using SSA from:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">demo3</span><span class="p">(</span><span class="kt">bool</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_2</span><span class="p">,</span> <span class="n">a_3</span><span class="p">;</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="mi">23</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="n">a_2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">a_3</span> <span class="o">=</span> <span class="n">phi</span><span class="p">(</span><span class="n">a_1</span><span class="p">,</span> <span class="n">a_2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a_3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="math">\Phi</span>-function is usually interpreted as “these variables
must be stored in the same memory location” during code generation. Most
modern compilers for imperative languages such as C/C++ use SSA form for
at least some of its passes as it is very easy to manipulate and
analyse.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>In recent years formal equivalence checking also became an important
verification method for validating RTL and lower abstraction
representation of the design.</p>
</dd>
</dl>
</div>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">Basic Principles</a><ul>
<li><a class="reference internal" href="#levels-of-abstraction">Levels of Abstraction</a><ul>
<li><a class="reference internal" href="#system-level">System Level</a></li>
<li><a class="reference internal" href="#high-level">High Level</a></li>
<li><a class="reference internal" href="#behavioural-level">Behavioural Level</a></li>
<li><a class="reference internal" href="#register-transfer-level-rtl">Register-Transfer Level (RTL)</a></li>
<li><a class="reference internal" href="#logical-gate-level">Logical Gate Level</a></li>
<li><a class="reference internal" href="#physical-gate-level">Physical Gate Level</a></li>
<li><a class="reference internal" href="#switch-level">Switch Level</a></li>
<li><a class="reference internal" href="#yosys">Yosys</a></li>
</ul>
</li>
<li><a class="reference internal" href="#features-of-synthesizable-verilog">Features of Synthesizable Verilog</a><ul>
<li><a class="reference internal" href="#structural-verilog">Structural Verilog</a></li>
<li><a class="reference internal" href="#expressions-in-verilog">Expressions in Verilog</a></li>
<li><a class="reference internal" href="#behavioural-modelling">Behavioural Modelling</a></li>
<li><a class="reference internal" href="#functions-and-tasks">Functions and Tasks</a></li>
<li><a class="reference internal" href="#conditionals-loops-and-generate-statements">Conditionals, Loops and Generate-Statements</a></li>
<li><a class="reference internal" href="#arrays-and-memories">Arrays and Memories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#challenges-in-digital-circuit-synthesis">Challenges in Digital Circuit Synthesis</a><ul>
<li><a class="reference internal" href="#standards-compliance">Standards Compliance</a></li>
<li><a class="reference internal" href="#optimizations">Optimizations</a></li>
<li><a class="reference internal" href="#technology-mapping">Technology Mapping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#script-based-synthesis-flows">Script-Based Synthesis Flows</a></li>
<li><a class="reference internal" href="#methods-from-compiler-design">Methods from Compiler Design</a><ul>
<li><a class="reference internal" href="#lexing-and-parsing">Lexing and Parsing</a></li>
<li><a class="reference internal" href="#multi-pass-compilation">Multi-Pass Compilation</a></li>
<li><a class="reference internal" href="#static-single-assignment-form">Static Single Assignment Form</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="CHAPTER_Intro.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L material-icons">arrow_back</i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>Introduction</div>
         </div>
     </a>
     <a id="button-next" href="CHAPTER_Approach.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
        <i class="pagenation-arrow-R material-icons">arrow_forward</i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>Approach</div>
        </div>
     </a>
</div>
        <footer class="mdl-mini-footer">
  <div class="mdl-mini-footer__left-section">
    <div class="mdl-logo">Yosys</div>
    <div>
      <ul>
        
        <li>
          <a href="https://symbiflow.github.io/" target="_blank">SymbiFlow</a>
        </li>
        <li>
          <a href="https://lists.librecores.org/listinfo/symbiflow" target="_blank">Mailing List</a>
        </li>
        <li>
          <a href="https://webchat.freenode.net/#symbiflow" target="_blank">IRC</a>
        </li>
        <li>
          <a href="https://join.slack.com/t/symbiflow/shared_invite/enQtNTkyMjcyNTkzOTY4LTU0MzhmYWNjOGMyMTkyNjA0MmEyMWM5OWY3ZDg5MWQ3ODlmOWQwZjk2YzBmMDBjMzkzMzNjYjkwYjAxZTMyNjQ"
            target="_blank">Slack</a>
        </li>

        <!-- This is to still take up space when none of the links above are shown in the footer -->
        <li style="visibility: hidden;">
          a
        </li>
      </ul>
    </div>
  </div>

  <div class="mdl-mini-footer__right-section">
    <div>&copy; Copyright 2012-2020, Claire Wolf.</div>
    <div>Generated by <a href="http://sphinx.pocoo.org/">Sphinx</a>
      3.3.1 using <a
        href="https://github.com/SymbiFlow/sphinx_symbiflow_theme">sphinx_symbiflow_theme</a>.</div>
  </div>
</footer>
        </main>
    </div>
  </body>
</html>